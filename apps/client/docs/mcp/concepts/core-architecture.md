# 核心架构

了解MCP如何连接客户端、服务器和大语言模型

模型上下文协议（MCP）建立在灵活、可扩展的架构上，使LLM应用程序和集成之间能够无缝通信。本文档涵盖了核心架构组件和概念。

## 概述

MCP遵循客户端-服务器架构，其中：

* **主机（Hosts）**是启动连接的LLM应用程序（如Claude桌面版或IDE）
* **客户端（Clients）**在主机应用程序内与服务器维持1:1的连接
* **服务器（Servers）**向客户端提供上下文、工具和提示

## 核心组件

### 协议层

协议层负责消息帧处理、请求/响应链接以及高级通信模式。

主要类包括：

* `Protocol`
* `Client`
* `Server`

```typescript
class Protocol<Request, Notification, Result> {
    // 处理传入请求
    setRequestHandler<T>(schema: T, handler: (request: T, extra: RequestHandlerExtra) => Promise<r>): void

    // 处理传入通知
    setNotificationHandler<T>(schema: T, handler: (notification: T) => Promise<void>): void

    // 发送请求并等待响应
    request<T>(request: Request, schema: T, options?: RequestOptions): Promise<T>

    // 发送单向通知
    notification(notification: Notification): Promise<void>
}
```

### 传输层

传输层处理客户端和服务器之间的实际通信。MCP支持多种传输机制：

1. **标准输入输出传输**
   * 使用标准输入/输出进行通信
   * 适用于本地进程
2. **HTTP与SSE传输**
   * 使用服务器发送事件（SSE）进行服务器到客户端的消息传输
   * 使用HTTP POST进行客户端到服务器的消息传输

所有传输都使用JSON-RPC 2.0交换消息。有关模型上下文协议消息格式的详细信息，请参阅规范。

### 消息类型

MCP有以下主要消息类型：

1. **请求（Requests）**：需要对方的响应
```typescript
interface Request {
  method: string;
  params?: { ... };
}
```

2. **结果（Results）**：请求的成功响应
```typescript
interface Result {
  [key: string]: unknown;
}
```

3. **错误（Errors）**：表示请求失败
```typescript
interface Error {
  code: number;
  message: string;
  data?: unknown;
}
```

4. **通知（Notifications）**：不需要响应的单向消息
```typescript
interface Notification {
  method: string;
  params?: { ... };
}
```

## 主要架构组成

以下是MCP架构的主要组成部分：

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│             │    │             │    │             │
│  MCP客户端  │◄───►  MCP传输层  │◄───►  MCP服务器  │
│             │    │             │    │             │
└─────────────┘    └─────────────┘    └─────────────┘
                                           │
                                           ▼
                                      ┌─────────────┐
                                      │             │
                                      │ 数据源/工具 │
                                      │             │
                                      └─────────────┘
```

### 主机

主机进程作为容器和协调器：

* 创建和管理多个客户端实例
* 控制客户端连接权限和生命周期
* 实施安全策略和同意要求
* 处理用户授权决策
* 协调AI/LLM集成和采样
* 管理跨客户端的上下文聚合

### 客户端

每个客户端由主机创建并维护与服务器的隔离连接：

* 与每个服务器建立一个有状态会话
* 处理协议协商和能力交换
* 双向路由协议消息
* 管理订阅和通知
* 维护服务器之间的安全边界

主机应用程序创建和管理多个客户端，每个客户端与特定服务器具有1:1的关系。

### 服务器

服务器提供专门的上下文和功能：

* 通过MCP原语公开资源、工具和提示
* 独立运行，具有明确的职责
* 通过客户端接口请求采样
* 必须尊重安全约束
* 可以是本地进程或远程服务

## 能力协商

模型上下文协议使用基于能力的协商系统，客户端和服务器在初始化期间明确声明其支持的功能。能力决定了会话期间可用的协议功能和原语。

* 服务器声明资源订阅、工具支持和提示模板等能力
* 客户端声明采样支持和通知处理等能力
* 双方必须在整个会话中尊重声明的能力
* 可以通过协议扩展协商其他能力

每种能力都会解锁会话期间使用的特定协议功能。例如：

* 已实现的服务器功能必须在服务器的能力中公布
* 发出资源订阅通知需要服务器声明订阅支持
* 工具调用需要服务器声明工具功能
* 采样需要客户端在其能力中声明支持

这种能力协商确保客户端和服务器对支持的功能有清晰的理解，同时保持协议的可扩展性。

## 安全模型

MCP内置了多层安全机制：

* **身份验证**：确认客户端身份
* **授权**：控制对资源和工具的访问
* **沙箱**：限制操作范围，防止越界访问
* **同意机制**：要求用户明确批准特定操作
* **隔离**：每个服务器连接保持独立的安全上下文
* **审计**：记录访问和操作历史

服务器实现负责强制执行这些安全策略，确保模型只能访问授权的资源和执行允许的操作，而主机应用程序负责管理用户同意和跨客户端的安全策略。 

## 用小朋友也能懂的话来说

想象一下，MCP就像一个神奇的邮局系统！🏤

在这个系统中：

**小明（主机）**是一个聪明的小朋友，他有很多信件要送给不同的商店，但他自己不能同时去所有地方。

**小明的好朋友们（客户端）**帮他送信，每个朋友只负责一个特定的商店。小明告诉他们要送哪些信，然后他们就出发了。

**各种商店（服务器）**收到信后，会按照信上的要求提供东西或服务。有的是图书馆提供书籍，有的是玩具店给玩具，还有的是糖果店提供糖果。

当小明的朋友到达商店时，他们会先打招呼说："你好！我能做什么？"（这就是**能力协商**）。商店会回答："我这里有图书、玩具或糖果，你想要哪个？"

小明的朋友可以用两种方式和商店交流：
- 发问题（**请求**）："请给我一本恐龙书好吗？"然后等待回答
- 告知消息（**通知**）："小明已经收到你送的玩具了，他很喜欢！"不需要等回答

为了确保安全，每家商店都有自己的规则：
- 要看小明朋友的身份证（**身份验证**）
- 只允许拿走被允许的东西（**授权**）
- 不能进入商店的员工区域（**沙箱**）
- 贵重物品需要先打电话给小明确认（**同意机制**）

最神奇的是，所有这些信息传递就像用特殊的传声筒（**传输层**）一样，可以是直接面对面说话（**标准输入输出**），也可以是用电话和短信（**HTTP和SSE**）。

通过这个神奇的系统，小明可以同时从许多不同的商店获取信息和服务，而不用自己跑来跑去，这就是MCP的魔力！🌟 